import { F as FreestyleExecuteScriptParamsConfiguration, a as FreestyleExecuteScriptResultSuccess, D as DeploymentSource, b as FreestyleDeployWebConfiguration, c as FreestyleDeployWebSuccessResponseV2, d as FreestyleCloudstateDeployRequest, e as FreestyleCloudstateDeploySuccessResponse, H as HandleBackupCloudstateResponse, f as HandleGetLogsResponse, g as HandleCreateDomainVerificationResponse, h as HandleVerifyDomainResponse, i as HandleVerifyDomainError, j as HandleListDomainsResponse, k as HandleListDomainVerificationRequestsResponse, l as HandleDeleteDomainVerificationResponse, m as HandleListWebDeploysResponse, n as HandleListExecuteRunsResponse, o as HandleGetExecuteRunResponse, p as HandleVerifyWildcardResponse, C as CreateRepositoryResponseSuccess, q as HandleListRepositoriesResponse, r as HandleDeleteRepoResponse, G as GitIdentity, s as HandleDeleteIdentityResponse, A as AccessLevel, t as HandleGrantPermissionResponse, L as ListPermissionResponseSuccess, u as DescribePermissionResponseSuccess, v as CreatedToken, w as ListGitTokensResponseSuccess, x as HandleListGitTriggersResponse, y as GitTrigger, z as GitTriggerAction, B as HandleCreateGitTriggerResponse } from './types.gen-0bQ5Wn0o.js';
export { J as AccessTokenInfo, I as AccessibleRepository, K as Behavior, M as BlobEncoding, N as BlobObject, O as CommitObject, P as CommitParent, Q as CommitTree, R as CreateDomainMappingRequest, S as CreateRecordParams, T as CreateRepoRequest, V as CreateRepoSource, U as CreateRepositoryRequest, X as CustomBuildOptions, E as DeploymentBuildOptions, Y as DeploymentLogEntry, _ as DeploymentState, $ as DevServer, a1 as DevServerRequest, a2 as DevServerStatusRequest, a3 as DevServerWatchFilesRequest, a4 as DnsRecord, a5 as DnsRecordData, a6 as DnsRecordKind, a7 as DomainVerificationRequest, a8 as ExecRequest, a9 as ExecuteLogEntry, aa as ExecuteRunInfo, ab as ExecuteRunState, ac as FileReadContent, ae as FreestyleCloudstateDeployConfiguration, af as FreestyleCloudstateDeployErrorResponse, ag as FreestyleDeleteDomainVerificationRequest, ah as FreestyleDeployWebErrorResponse, ai as FreestyleDeployWebPayload, aj as FreestyleDeployWebPayloadV2, ak as FreestyleDomainVerificationRequest, al as FreestyleExecuteScriptParams, am as FreestyleFile, an as FreestyleGetLogsResponse, ao as FreestyleJavaScriptLog, ap as FreestyleLogResponseObject, aq as FreestyleNetworkPermission, as as FreestyleVerifyDomainRequest, at as GitCommitPushRequest, au as GitContents, aw as GitContentsDirEntryItem, ax as GitReference, ay as GitRepositoryTrigger, aB as GrantPermissionRequest, aW as HandleBackupCloudstateData, aX as HandleBackupCloudstateError, bg as HandleCreateDomainVerificationData, bh as HandleCreateDomainVerificationError, cb as HandleCreateGitTokenData, cd as HandleCreateGitTokenError, cc as HandleCreateGitTokenResponse, cO as HandleCreateGitTriggerData, cP as HandleCreateGitTriggerError, bT as HandleCreateIdentityError, bS as HandleCreateIdentityResponse, a$ as HandleCreateRecordData, b1 as HandleCreateRecordError, b0 as HandleCreateRecordResponse, cj as HandleCreateRepoData, cl as HandleCreateRepoError, ck as HandleCreateRepoResponse, bb as HandleDeleteDomainMappingData, bd as HandleDeleteDomainMappingError, bc as HandleDeleteDomainMappingResponse, bi as HandleDeleteDomainVerificationData, bj as HandleDeleteDomainVerificationError, cQ as HandleDeleteGitTriggerData, cS as HandleDeleteGitTriggerError, cR as HandleDeleteGitTriggerResponse, bU as HandleDeleteIdentityData, bV as HandleDeleteIdentityError, b2 as HandleDeleteRecordData, b4 as HandleDeleteRecordError, b3 as HandleDeleteRecordResponse, cm as HandleDeleteRepoData, cn as HandleDeleteRepoError, aT as HandleDeployCloudstateData, aV as HandleDeployCloudstateError, aU as HandleDeployCloudstateResponse, cV as HandleDeployWebData, cX as HandleDeployWebError, cW as HandleDeployWebResponse, cY as HandleDeployWebV2Data, c_ as HandleDeployWebV2Error, cZ as HandleDeployWebV2Response, bZ as HandleDescribePermissionData, b$ as HandleDescribePermissionError, b_ as HandleDescribePermissionResponse, bC as HandleDevServerStatusData, bE as HandleDevServerStatusError, bD as HandleDevServerStatusResponse, cJ as HandleDownloadTarballData, cL as HandleDownloadTarballError, cK as HandleDownloadTarballResponse, bk as HandleEphemeralDevServerData, bm as HandleEphemeralDevServerError, bl as HandleEphemeralDevServerResponse, bn as HandleExecOnEphemeralDevServerData, bp as HandleExecOnEphemeralDevServerError, bo as HandleExecOnEphemeralDevServerResponse, bM as HandleExecuteScriptData, bO as HandleExecuteScriptError, bN as HandleExecuteScriptResponse, cr as HandleGetBlobData, ct as HandleGetBlobError, cs as HandleGetBlobResponse, cu as HandleGetCommitData, cw as HandleGetCommitError, cv as HandleGetCommitResponse, co as HandleGetContentsData, cq as HandleGetContentsError, cp as HandleGetContentsResponse, bK as HandleGetExecuteRunData, bL as HandleGetExecuteRunError, cT as HandleGetLogsData, cU as HandleGetLogsError, cx as HandleGetRefBranchData, cz as HandleGetRefBranchError, cy as HandleGetRefBranchResponse, cA as HandleGetRefTagData, cC as HandleGetRefTagError, cB as HandleGetRefTagResponse, cD as HandleGetTagData, cF as HandleGetTagError, cE as HandleGetTagResponse, cG as HandleGetTreeData, cI as HandleGetTreeError, cH as HandleGetTreeResponse, d1 as HandleGetWebDeployDetailsData, bw as HandleGitCommitPushData, by as HandleGitCommitPushError, bx as HandleGitCommitPushResponse, c0 as HandleGrantPermissionData, c1 as HandleGrantPermissionError, b8 as HandleInsertDomainMappingData, ba as HandleInsertDomainMappingError, b9 as HandleInsertDomainMappingResponse, be as HandleListDomainVerificationRequestsError, b7 as HandleListDomainsError, bI as HandleListExecuteRunsData, bJ as HandleListExecuteRunsError, c8 as HandleListGitTokensData, ca as HandleListGitTokensError, c9 as HandleListGitTokensResponse, cM as HandleListGitTriggersData, cN as HandleListGitTriggersError, bP as HandleListIdentitiesData, bR as HandleListIdentitiesError, bQ as HandleListIdentitiesResponse, bW as HandleListPermissionsData, bY as HandleListPermissionsError, bX as HandleListPermissionsResponse, aY as HandleListRecordsData, a_ as HandleListRecordsError, aZ as HandleListRecordsResponse, ch as HandleListRepositoriesData, ci as HandleListRepositoriesError, c$ as HandleListWebDeploysData, d0 as HandleListWebDeploysError, bt as HandleReadFileFromEphemeralDevServerData, bv as HandleReadFileFromEphemeralDevServerError, bu as HandleReadFileFromEphemeralDevServerResponse, ce as HandleRevokeGitTokenData, cg as HandleRevokeGitTokenError, cf as HandleRevokeGitTokenResponse, c2 as HandleRevokePermissionData, c4 as HandleRevokePermissionError, c3 as HandleRevokePermissionResponse, bz as HandleShutdownDevServerData, bB as HandleShutdownDevServerError, bA as HandleShutdownDevServerResponse, c5 as HandleUpdatePermissionData, c7 as HandleUpdatePermissionError, c6 as HandleUpdatePermissionResponse, bf as HandleVerifyDomainData, b5 as HandleVerifyWildcardData, b6 as HandleVerifyWildcardError, bF as HandleWatchDevServerFilesData, bH as HandleWatchDevServerFilesError, bG as HandleWatchDevServerFilesResponse, bq as HandleWriteFileFromEphemeralDevServerData, bs as HandleWriteFileFromEphemeralDevServerError, br as HandleWriteFileFromEphemeralDevServerResponse, aC as InternalServerError, aD as ListRecordsResponse, aE as NetworkPermissionData, aF as ReadFileEphemeralDevServerResponses, aG as ReadFileRequest, aH as RepositoryInfo, aI as RevokeGitTokenRequest, aJ as ShutdownDevServerRequest, aK as Signature, aL as TagObject, aM as TagTarget, aN as TreeEntry, aP as TreeObject, aQ as UpdatePermissionRequest, aR as Visibility, aS as WriteFileRequest, ar as action, aA as action2, az as event, Z as kind, a0 as kind2, ad as kind3, W as type, av as type2, aO as type3 } from './types.gen-0bQ5Wn0o.js';

interface FreestyleDevServer {
    /**
     * The URL for the dev server's HTTP API.
     */
    ephemeralUrl: string;
    /**
     * The URL to the MCP endpoint for the dev server.
     */
    mcpEphemeralUrl: string;
    /**
     * The URL for the VSCode server running in the dev server.
     */
    codeServerUrl: string;
    /**
     * Whether the dev server was just created.
     */
    isNew: boolean;
    fs: FreestyleDevServerFilesystem;
    process: FreestyleDevServerProcess;
    devCommandRunning: boolean;
    installCommandRunning: boolean;
    /**
     * Get the status of the dev server
     */
    status(): Promise<{
        installing: boolean;
        devRunning: boolean;
    }>;
    /**
     * Commit and push changes to the dev server repository
     * @param message The commit message
     */
    commitAndPush(message: string): Promise<void>;
    /**
     * Shutdown the dev server
     */
    shutdown(): Promise<{
        success: boolean;
        message: string;
    }>;
}
interface FreestyleDevServerFilesystem {
    /**
     * List files in the dev server directory
     */
    ls(path?: string): Promise<Array<string>>;
    /**
     * Read a file from the dev server
     * @param path The path to the file
     * @param encoding The encoding to use (defaults to utf-8)
     */
    readFile(path: string, encoding?: string): Promise<string>;
    /**
     * Write a file to the dev server
     * @param path The path to write to
     * @param content The content to write
     * @param encoding The encoding to use (defaults to utf-8)
     */
    writeFile(path: string, content: string | ArrayBufferLike, encoding?: string): Promise<void>;
    watch(): AsyncGenerator<{
        eventType: string;
        filename: string;
    }>;
}
interface FreestyleDevServerProcess {
    /**
     * Execute a command on the dev server
     * @param cmd The command to execute
     * @param background Whether to run the command in the background
     */
    exec(cmd: string, background?: boolean): Promise<{
        id: string;
        isNew: boolean;
        stdout?: string[];
        stderr?: string[];
    }>;
}

type Options = {
    /**
     * The base URL for the API.
     */
    baseUrl?: string;
    /**
     * The API key to use for requests.
     */
    apiKey?: string;
    /**
     * Custom Headers to be sent with each request.
     */
    headers?: Record<string, string>;
};
declare class FreestyleSandboxes {
    private client;
    options: Options;
    constructor(options?: Options);
    /**
     * Execute a script in a sandbox.
     */
    executeScript(script: string, config?: FreestyleExecuteScriptParamsConfiguration): Promise<FreestyleExecuteScriptResultSuccess>;
    /**
     * Deploy a Web project to a sandbox.
     */
    deployWeb(source: DeploymentSource, config?: FreestyleDeployWebConfiguration): Promise<FreestyleDeployWebSuccessResponseV2>;
    /**
     * Deploy a Cloudstate project to a sandbox.
     */
    deployCloudstate(body: FreestyleCloudstateDeployRequest): Promise<FreestyleCloudstateDeploySuccessResponse>;
    /**
     * Get a backup of a Cloudstate project in a sandbox.
     * @param id The ID of the Cloudstate project.
     * @returns The backup of the Cloudstate project.
     * @throws An error if the backup could not be retrieved.
     */
    backupCloudstate(id: string): Promise<HandleBackupCloudstateResponse>;
    /**
     * Get logs for an execute run, or web deployment.
     * @param id The ID of the sandbox.
     * @returns The logs for the sandbox.
     * @throws An error if the logs could not be retrieved.
     */
    getLogs(id: string): Promise<HandleGetLogsResponse>;
    /**
     * Create a a domain verification request.
     * @param domain The domain to verify.
     * @returns The domain verification token.
     */
    createDomainVerificationRequest(domain: string): Promise<HandleCreateDomainVerificationResponse>;
    /**
     * Verify a domain. Note, this requires the domain verification token to be already set up.
     * @param domain The domain to verify.
     * @returns The domain verification request.
     */
    verifyDomain(domain: string): Promise<HandleVerifyDomainResponse | HandleVerifyDomainError>;
    listDomains(): Promise<HandleListDomainsResponse>;
    listDomainVerificationRequests(): Promise<HandleListDomainVerificationRequestsResponse>;
    deleteDomainVerificationRequest(domain: string, verificationCode: string): Promise<HandleDeleteDomainVerificationResponse>;
    listWebDeployments(limit?: number, offset?: number): Promise<HandleListWebDeploysResponse>;
    listExecuteRuns(limit?: number, offset?: number): Promise<HandleListExecuteRunsResponse>;
    getExecuteRun(id: string): Promise<HandleGetExecuteRunResponse>;
    /** Provision a wildcard certificate for domain. */
    provisionWildcard(domain: string): Promise<HandleVerifyWildcardResponse>;
    /**
     * Create a new git repository.
     */
    createGitRepository({ name, public: pub, source, }: {
        name: string;
        public?: boolean;
        source?: {
            type: "git";
            url: string;
            branch?: string;
            depth?: number;
        };
    }): Promise<CreateRepositoryResponseSuccess>;
    /**
     * List git repositories.
     */
    listGitRepositories({ limit, offset, }?: {
        limit?: number;
        offset?: number;
    }): Promise<HandleListRepositoriesResponse>;
    /**
     * Delete a git repository.
     */
    deleteGitRepository({ repoId, }: {
        repoId: string;
    }): Promise<HandleDeleteRepoResponse>;
    /**
     * Create a new git identity.
     */
    createGitIdentity(): Promise<GitIdentity>;
    /**
     * Delete a git identity.
     */
    deleteGitIdentity({ identityId, }: {
        identityId: string;
    }): Promise<HandleDeleteIdentityResponse>;
    /**
     * Grant a git identity access to a repository.
     */
    grantGitPermission({ repoId, identityId, permission, }: {
        repoId: string;
        identityId: string;
        permission: AccessLevel;
    }): Promise<HandleGrantPermissionResponse>;
    /**
     * Update a git identity's permissions on a repository.
     */
    updateGitPermission({ repoId, identityId, permission, }: {
        repoId: string;
        identityId: string;
        permission: AccessLevel;
    }): Promise<void>;
    /**
     * Revoke a git identity's access to a repository.
     */
    revokeGitPermission({ repoId, identityId, }: {
        repoId: string;
        identityId: string;
    }): Promise<void>;
    /**
     * List access permissions for a git identity.
     */
    listGitPermissions({ identityId, }: {
        identityId: string;
    }): Promise<ListPermissionResponseSuccess>;
    /**
     * Get the permission of a git identity on a repository.
     */
    getGitPermission({ repoId, identityId, }: {
        repoId: string;
        identityId: string;
    }): Promise<DescribePermissionResponseSuccess>;
    /**
     * Create a new git access token for an identity.
     */
    createGitAccessToken({ identityId, }: {
        identityId: string;
    }): Promise<CreatedToken>;
    /**
     * Revoke a git access token.
     */
    revokeGitAccessToken({ identityId, tokenId, }: {
        identityId: string;
        tokenId: string;
    }): Promise<void>;
    /**
     * List git access tokens for an identity.
     */
    listGitAccessTokens({ identityId, }: {
        identityId: string;
    }): Promise<ListGitTokensResponseSuccess>;
    /**
     * List git triggers for a repository.
     */
    listGitTriggers({ repoId, }: {
        repoId: string;
    }): Promise<HandleListGitTriggersResponse>;
    /**
     * Create a git trigger for a repository.
     */
    createGitTrigger({ repoId, trigger, action, }: {
        repoId: string;
        trigger: GitTrigger;
        action: GitTriggerAction;
    }): Promise<HandleCreateGitTriggerResponse>;
    /**
     * Delete a git trigger.
     */
    deleteGitTrigger({ triggerId }: {
        triggerId: string;
    }): Promise<void>;
    /**
     * Request a dev server for a repository. If a dev server is already running
     * for that repository, it will return a url to that server. Dev servers are
     * ephemeral so you should call this function every time you need a url. Do
     * not store the url in your database!
     */
    requestDevServer(options: {
        /**
         * @deprecated
         */
        repoUrl?: string;
        repoId?: string;
        /**
         * @deprecated
         */
        repo?: string;
        baseId?: string;
        devCommand?: string;
        preDevCommandOnce?: string;
        envVars?: Record<string, string>;
        computeClass?: string;
        timeout?: number;
    }): Promise<FreestyleDevServer>;
    fetch(path: string, init?: RequestInit): Promise<Response>;
}

export { AccessLevel, CreateRepositoryResponseSuccess, CreatedToken, DeploymentSource, DescribePermissionResponseSuccess, FreestyleCloudstateDeployRequest, FreestyleCloudstateDeploySuccessResponse, FreestyleDeployWebConfiguration, FreestyleDeployWebSuccessResponseV2, type FreestyleDevServer, type FreestyleDevServerFilesystem, FreestyleExecuteScriptParamsConfiguration, FreestyleExecuteScriptResultSuccess, FreestyleSandboxes, GitIdentity, GitTrigger, GitTriggerAction, HandleBackupCloudstateResponse, HandleCreateDomainVerificationResponse, HandleCreateGitTriggerResponse, HandleDeleteDomainVerificationResponse, HandleDeleteIdentityResponse, HandleDeleteRepoResponse, HandleGetExecuteRunResponse, HandleGetLogsResponse, HandleGrantPermissionResponse, HandleListDomainVerificationRequestsResponse, HandleListDomainsResponse, HandleListExecuteRunsResponse, HandleListGitTriggersResponse, HandleListRepositoriesResponse, HandleListWebDeploysResponse, HandleVerifyDomainError, HandleVerifyDomainResponse, HandleVerifyWildcardResponse, ListGitTokensResponseSuccess, ListPermissionResponseSuccess };
